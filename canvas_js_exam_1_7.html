<!DOCTYPE html> 
<html lang="en"> <!-- 기본언어 : 영어-->
<head>
    <meta charset="UTF-8" /> <!--페이지 언어 인코딩 형식-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <!--화면크기에 따라 보여지는 크기 맞추기-->
    <title>Web Animation(canvas_js_css)[1단원-3]</title> 
    <style>
        /* 페이지 전체 설정*/
        body {
            margin: 0;
            padding: 0;
            text-align: center;
            font-family: sans-serif;
        }
        /* 애니메이션 화면 설정 */
        #canvas {
            background: #DCD7C9;
            display: block;
            margin: 0 auto;
        }

        /* pc 안내 문구 기본은 숨김 */
        .pc-guide {
            display: none;/* : 화면에 보여지지 않게함*/
            margin-top: 10px;
            font-size: 16px;
            color: #333; 
            font-weight: bold;
        }

        /* PC에서는 600x600 고정 */
        @media (min-width: 769px) {
            #canvas {
                width: 600px;
                height: 600px;
          }

            .pc-guide{
                display:block; /*★1_5 : pc-guide를 pc에서 접속시 보이게함 */
            }
        }

        /*  버튼들을 감싸는 div 숨기기 (pc에서는 안 보이게하고 스마트폰에서 접속이 보임)
            ★1_7 : 코드추가 및 수정, 스마트폰에서 보여질 버튼 모양 설정*/
        .controls {
            display: none; /* 화면에 보이지 않게함 */
            margin-top: 10px; 
            flex-direction: column;
            align-items: center;
        }

        /* ★1_7 : 코드추가 및 수정, 스마트폰에서 보여질 버튼 모양 설정 */
        /* ★1_7 : .controls 안에 있는 .row 요소에 스타일 적용 */
        .controls .row {
            display: flex; /* ★1_7 : .row를 플렉스 컨테이너로 설정 → 자식 요소를 가로 방향으로 배치*/
            justify-content: center;/* ★1_7 : 가로 가운데 정렬 */
        }

        /* ★1_7 : 코드추가 및 수정, 스마트폰에서 보여질 버튼 모양 설정 */
        .controls button{
            font-size: 24px; 
            padding: 15px 20px; 
            margin: 5px;
            min-width: 60px;
            border-radius: 10px;
            border: none; /*선두께 없음 */
            background-color: #333;
            color: white;
            touch-action: none; /* ★1_7 : 터치 딜레이 방지 */
            user-select: none;         /*← ★1_7 : 텍스트 선택 방지 : 누르고 있을 때 복사등 메뉴 보이지 않게함 */
            -webkit-user-select: none; /*← ★1_7 : ios/안드로이드 크롬 */
        }

        /* ★1_7 : 버튼을 누르고 있을 때(active) 아래 지정한 배경색으로 변경 */
        .controls button:active {
            background-color: #555;
        }

        /* 화면이 작을 때 (스마트폰 등에서 보인다면 아래 코드동작)
            화면의 폭이 최대 768픽셀보다 이하이면 아래 css동작함 아니면 위 pc용 css @media (min-width: 769px)동작함
            어 최근 스마트폰의 해상도는 pc보다도 좋은 경우가 많은데 768픽셀보다 작으면 스마트폰이라니?
            ★이유 : 스마트폰의 물리적인 해상도는 더 크지만, 화면을 작게 보이도록 하기 위해 **디바이스 픽셀 비율(DRR, devicePixelRatio)**을 사용함
            아이폰13의 가로해상도가 1170픽셀인데 CSS픽셀로는 1170/3=390픽셀임
            현재 기기로 보아도 768 css픽셀이면 모든 스마트폰에서 접속하는 것으로 판단함^^
        */
        @media (max-width: 768px) {
            #canvas {
                width: 100vw; /* ★1_5 : 스마트폰 화면 canvas 가로 전체 크기로함 */
                height: 100vw; /* ★1_5 : 화면 canvas 세로 = 가로 (정사각형) */
            }
            .controls{
                display: block; /* ★1_5 : 스마트폰에서 접속시 controls을 보이게함 */
            }
            .pc-guide{
                display: none; /* ★1_5 : pc-guide를 스마트폰 접속시 숨김 */
            }
        }
    </style> 
</head>
<body>
    <!--애니메이션 화면 만들기-->
    <canvas id="canvas"></canvas> 

    <!-- ★1_7 :  DDD -->
    <!-- 애니메이션 화면 만들기 : 스마트폰에서 접속 할 때만 controls이 보이게됨-->
    <!-- ★1_7 : 아래처럼 코드를 변경하자, 배치 모양을 키보드 방향키 처럼 변경-->
    <div class="controls">
        <div class="row">
            <button id="upBtn">△</button>
        </div>
        <div class="row">
            <button id="leftBtn">◁</button>
            <button id="downBtn">▽</button>
            <button id="rightBtn">▷</button>
        </div>
    </div>

    <!--★1_5 : pc 전용 안내 문구-->
    <div class="pc-guide">
        PC에서 접속했습니다. 방향키로 이동하세요.<br>
        스마트폰은 접속 시 보이는 버튼으로 이동하세요.
    </div>



    <script>
        // 캔버스 요소 JS 변수 만들기
        const drawingBoard = document.getElementById('canvas'); 
        // 캔버스에 2D그림을 그리는 도구 변수만들기
        const drawingPen = drawingBoard.getContext('2d'); 

        // 캔버스 내부 해상도는 무조건 600x600 고정(pc, 스마트폰 모두)
        drawingBoard.width = 600; 
        drawingBoard.height = 600; 

        //화면 가운데 위치
        let x = (drawingBoard.width - 10) / 2; 
        let y = (drawingBoard.height - 10) / 2;

        //주인공 이동속도
        const moveAmount = 5; 

        // ★1_6 : EEE
        //주인공 이동함수
        function moveRight() {
            x = x + moveAmount;
        }

        function moveLeft() {
            x = x - moveAmount;
        }

        function moveDown() {
            y = y + moveAmount;
        }

        function moveUp() {
            y = y - moveAmount;
        }
        //주인공 이동제한
        function move_limit(){
            if (x < 0){ //왼쪽이동제한
                x = 0;
            }
            /*if (x > 590){
                x=590;
            }
            if(y < 0){
                y=0;
            }
            if(y > 590){
                y=590;
            } */
        }

        //캔버스 왼쪽 상당에 텍스트 출력함수
        function drawCoordinate() {
            drawingPen.fillStyle = 'black';
            drawingPen.foot = '10px sans-serif';
            drawingPen.fillText(`x: ${x} y: ${y}`, 10, 20);
        }

        //주인공출력함수
        function drawHere() {
            drawingPen.fillStyle = 'black';
            drawingPen.fillRect(x, y, 10, 10);
        }

        // 방향키 눌림 상태 추적
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            ArrowUp: false,
            ArrowDown: false
        };

        // 키보드를 keydown 시 처리
        document.addEventListener('keydown', (e) => {
            // ★1_6 : e.key는 현재 선택한 키보드를 말한다.
            // ★1_6 : hasOwnProperty는 keys변수인의 값이 있으면 true 없으면 false를 반환한다.
            // ★1_6 : 즉 e.key로 keys에 정의 한 키보드가 선택되면 true를 반환해서 아래 조건문을 만족한다.
            //         왼쪽방향을 선택하면 선택된 키보드 기본값
            // ★1_6 : ArrowLeft: false를 true로 변경해서 function draw()함수 안쪽의
            //         if (keys.ArrowLeft) 조건이 true가 되고 moveLeft(); 왼쪽이동 함수를 이동해서
            // ★1_6 : setInterval(draw, 16); // 60FPS 만큼 캐릭터가 이동한다 즉 타이머 속도만큼 주인공이 이동한다.
            // ★1_6 : 모르면 선생님에게 질문해서 내용을 이해하자. ^^
            if (keys.hasOwnProperty(e.key)) {
                // ★1_6 : 키보드중 keys변수에 기록한 키보드가 keydown 되었을 때 값을 선택 되었다 true로 변경
                keys[e.key] = true;
            }
        });

        // 키보드를 keyup 시 처리
        document.addEventListener('keyup', (e) => {
            // ★1_6 : 해당키를 선택하다 keyup하면 해당키 값을 false로 변경해서 멈추게 된다.
            // ★1_6 : 모르면 선생님에게 질문해서 내용을 이해하자.^^
            if(keys.hasOwnProperty(e.key)) {
                // ★1_6 : 키보드중 keys변수에 기록한 키보드가 keyup 되었을 때 값을 선택 되었다 false로 변경
                keys[e.key] = false;
            }
        });

        // 화면에 출력하기
        function draw() {
            drawingPen.clearRect(0, 0, canvas.width, canvas.height); //화면지우기
            drawHere(); //주인공출력함수호출

            move_limit(); // 주인공 이동제한 함수호출
            drawCoordinate(); // 텍스트 출력 함수호출
            
            // ★1_7 : EEE
            // ★1_6 : 키가 눌려있는 동안 계속 이동(키보드 인식 속도 향상으로 이동을 부드럽게 변경
            if (keys.ArrowLeft) moveLeft(); // 왼쪽 방향키를 선택해서 keys.ArrowLeft 값이 true일때 처리
            if (keys.ArrowRight) moveRight();
            if (keys.ArrowUp) moveUp(); 
            if (keys.ArrowDown) moveDown(); 
        }

        setInterval(draw, 16); // 60FPS

        // ★1_7 : AAA
        // ★1_7 : 모바일 버튼을 누르고 있을 때도 상태 관리
        const setBtnHold = (key, isDown) => {
            // ★1_7 : setBtnHold는 특정 키(key)의 눌림 상태(isDown)를 저장
            // ★1_7 : setBtnHold(key, true) 전달하면 받은 상태 저장함
            keys[key] = isDown;
        }
        
        // ★1_7 : BBB
        const bindButton = (id,key) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', () => setBtnHold(key, true));
            btn.addEventListener('touchend', () => setBtnHold(key, false));
            btn.addEventListener('mousedown', () => setBtnHold(key, true)); // 마우스도 지원
            btn.addEventListener('mouseup', () => setBtnHold(key, false));
            btn.addEventListener('mouseleave', () => setBtnHold(key, false)); // 끌고 나갈 때
        };
        
        // ★1_7 : CCC
        // ★1_7 : 마우스로 각 버튼을 선택시 키보드 방향키 동작 연결
        bindButton("leftBtn", "ArrowLeft"); // ★1_7 : 왼쪽 버튼
        bindButton("rightBtn", "ArrowRight"); // ★1_7 : 오른쪽 버튼
        bindButton("upBtn", "ArrowUp"); // ★1_7 : 위쪽 버튼
        bindButton("downBtn", "ArrowDown"); // ★1_7 :  아래쪽 버튼

        // ★1_7 : 모바일 화면에서 버튼 손으로 선택시 함수 실행순서
        // 1) DDD 버튼을 출력
        // 2) AAA setBtnHold 함수 정의됨
        // 3) BBB bindButton 함수 정의됨
        // 4) DDD의 왼쪽 버튼을 손으로 선택시 CCC의 bindButton("leftBtn", "ArrowLeft"); 호출
        // 5) BBB의 bindButton함수가 호출되고 (id, key) 값이 ("leftBtn", "ArrowLeft")로 전달
        // 6) BBB의 전달받은 id="leftBtn"로 아래 const btn = document.getElementById(id); 에 id전달
        // 7) BBB해당 id의 버튼이 화면에 <button id="leftBtn"></button> 있으므로 버튼 요소를 btn 변수에 저장
        // 8) BBB의 btn의 이벤트 리스너를 미리 모두 등록함(현재 왼쪽 방향키 버튼을 선택했다고 하자)
        //    값을 저장할 뿐 아직 선택한 버튼의 동작하지 않고 값만 기억함
        //    touchstart , setBtnHold("ArrowLeft", true) 왼쪽이동 버튼을 터치시 true(이동) 등록
        //    touchend, => setBtnHold("ArrowLeft", false) 왼쪽이동 버튼을 터치 종료시 false(멈춤)등록
        //    mousedown, => setBtnHold("ArrowLeft", true) 왼쪽이동 버튼을 마우스선택시 true(이동)등록
        //    mouseup, => setBtnHold("ArrowLeft", false) 왼쪽이동 버튼을 마우스선택 종료시 false(멈춤) 등록
        //    mouseleave, => setBtnHold("ArrowLeft", false) 왼쪽이동 버튼에서 마우스가 벗어나면 false(멈춤)등록
        // 9) 4)번에서 손으로 선택했으므로
        //    touchstart => setBtnHold("ArrowLeft", true)가 동작하면 => setBtnHold(key, true) 호출
        // 10) AAA의 => setBtnHold(key, isDown)함수에 ("ArrowLeft", true)전달되며
        //    함수의 keys[key]=isDown;에 keys[key]="ArrowLeft"가 true됨
        // 11) EEE의 키보드가 선택 되었을 때 실행되는 코드 if (keys.ArrowLeft) moveLeft(); 가 호출되고
        //     keys.ArrowLeft가 true가 되어 왼쪽 이동함수 moveLeft(); 가 호출되어 왼쪽이동됨
        // 12) 4)에서 버튼을 계속 누르고 있으면 계속 이동함
        // 13) 버튼에서 손을 떼면 touched -> setBtnHold("ArrowLeft", false)가 되어 이동을 멈춤
        // 14) 천천이 여러번 읽고 이해하자. 어려우면 선생님과 대화

        // ★1_7 : 아래 버튼 선택방식 제외 주석문 처리 할 것
        // 누르고 있을 때 연속동작 즉 주인공 이동 안함, 클릭을 반복해야 이동함, 누그로 있어도 이동하도록 수정
        // 버튼 이벤트 연결 : 버튼을 선택하면 해당 함수를 호출해서 주인공 이동
        /* 주석처리
        document.getElementById('leftBtn').addEventListener('click', moveLeft);
        document.getElementById('rightBtn').addEventListener('click', moveRight);
        document.getElementById('upBtn').addEventListener('click', moveUp);
        document.getElementById('downBtn').addEventListener('click', moveDown); */
    </script>
</body>
</html>